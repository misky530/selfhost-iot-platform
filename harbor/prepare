#!/bin/bash
set -e

# If compiling source code this dir is harbor's make dir.
# If installing harbor via package, this dir is harbor's root dir.
if [[ -n "$HARBOR_BUNDLE_DIR" ]]; then
    harbor_prepare_path=$HARBOR_BUNDLE_DIR
else
    harbor_prepare_path="$( cd "$(dirname "$0")" ; pwd -P )"
fi
echo "prepare base dir is set to ${harbor_prepare_path}"

# Clean up input dir
rm -rf ${harbor_prepare_path}/input
# Create a input dirs
mkdir -p ${harbor_prepare_path}/input
input_dir=${harbor_prepare_path}/input

# --- START: WINDOWS/MINGW PATH FIX ---
# Detect if running in Git Bash/MinGW environment
if [[ "$(uname -s)" == *MINGW* ]] || [[ "$(uname -s)" == *MSYS* ]]; then
    echo "Detected MinGW/Git Bash environment. Applying path fix for Docker volume mount."

    # 1. Create Docker-compatible paths with a leading double slash (//).
    #    Example: /d/code/harbor -> //d/code/harbor
    DOCKER_INPUT_DIR="/${input_dir}"
    DOCKER_HARBOR_PATH="/${harbor_prepare_path}"

    # Note: We keep the original MINGW paths ($input_dir, $harbor_prepare_path)
    # for internal script commands like cp and mkdir, and use the new DOCKER_* # variables only in the final 'docker run' command.

    # We intentionally leave the reassignments from the previous attempt commented out
    # as they did not solve the volume mount issue but may be needed for debugging:
    # harbor_prepare_path=$(pwd -P)
    # input_dir="${harbor_prepare_path}/input"
fi
# --- END: WINDOWS/MINGW PATH FIX ---


# Copy harbor.yml to input dir
if [[ ! "$1" =~ ^\-\- ]] && [ -f "$1" ]
then
    cp $1 $input_dir/harbor.yml
    shift
else
    if [ -f "${harbor_prepare_path}/harbor.yml" ];then
        # The file is in the root dir, copy it to the input staging dir
        cp ${harbor_prepare_path}/harbor.yml $input_dir/harbor.yml
    else
        echo "no config file: ${harbor_prepare_path}/harbor.yml"
        exit 1
    fi
fi

# The rest of the script is unchanged...

data_path=$(grep '^[^#]*data_volume:' $input_dir/harbor.yml | awk '{print $NF}')

# If previous secretkeys exist, move it to new location
previous_secretkey_path=/data/secretkey
previous_defaultalias_path=/data/defaultalias

if [ -f $previous_secretkey_path ]; then
    mkdir -p $data_path/secret/keys
    mv $previous_secretkey_path $data_path/secret/keys
fi
if [ -f $previous_defaultalias_path ]; then
    mkdir -p $data_path/secret/keys
    mv $previous_defaultalias_path $data_path/secret/keys
fi


# Create secret dir
secret_dir=${data_path}/secret
config_dir=$harbor_prepare_path/common/config

# --- START: WINDOWS/MINGW PATH FIX (Post-data_path) ---
if [[ "$(uname -s)" == *MINGW* ]] || [[ "$(uname -s)" == *MSYS* ]]; then
    # Ensure config_dir is also converted
    DOCKER_CONFIG_DIR="/${config_dir}"

    # Ensure data_path is absolute before conversion
    if [[ "$data_path" != /* ]]; then
        data_path="${harbor_prepare_path}/${data_path}"
    fi
    # Now convert the absolute data_path to Docker-compatible format
    DOCKER_DATA_PATH="/${data_path}"
fi
# --- END: WINDOWS/MINGW PATH FIX (Post-data_path) ---


# Set the prepare base dir, for mac, it should be $HOME, for linux, it should be /
# The certificate and the data directory in harbor.yaml should be sub directories of $HOME when installing Harbor in MacOS
prepare_base_dir=/
if [ "$(uname)" == "Darwin" ]; then
    prepare_base_dir=$HOME
fi

# Run prepare script
# Use the DOCKER_* variables if they were set (in MINGW),
# otherwise fallback to the standard MINGW paths ($input_dir, $harbor_prepare_path, etc.).
docker run --rm -v ${DOCKER_INPUT_DIR:-$input_dir}:/input \
                     -v ${DOCKER_DATA_PATH:-$data_path}:/data \
                     -v ${DOCKER_HARBOR_PATH:-$harbor_prepare_path}:/compose_location \
                     -v ${DOCKER_CONFIG_DIR:-$config_dir}:/config \
                     -v ${prepare_base_dir}:/hostfs${prepare_base_dir} \
                     --privileged \
                     goharbor/prepare:v2.14.1 prepare $@

echo "Clean up the input dir"
# Clean up input dir
rm -rf ${harbor_prepare_path}/input
